{"ast":null,"code":"\"use strict\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cropTensor = exports.capture = void 0;\nvar tf = require(\"@tensorflow/tfjs\");\n/**\r\n * Receives an image and normalizes it between -1 and 1.\r\n * Returns a batched image (1 - element batch) of shape [1, w, h, c]\r\n * @param rasterElement the element with pixels to convert to a Tensor\r\n * @param grayscale optinal flag that changes the crop to [1, w, h, 1]\r\n */\nfunction capture(rasterElement, grayscale) {\n  return tf.tidy(function () {\n    var pixels = tf.browser.fromPixels(rasterElement);\n    // crop the image so we're using the center square\n    var cropped = cropTensor(pixels, grayscale);\n    // Expand the outer most dimension so we have a batch size of 1\n    var batchedImage = cropped.expandDims(0);\n    // Normalize the image between -1 and a1. The image comes in between 0-255\n    // so we divide by 127 and subtract 1.\n    return batchedImage.toFloat().div(tf.scalar(127)).sub(tf.scalar(1));\n  });\n}\nexports.capture = capture;\nfunction cropTensor(img, grayscaleModel, grayscaleInput) {\n  var size = Math.min(img.shape[0], img.shape[1]);\n  var centerHeight = img.shape[0] / 2;\n  var beginHeight = centerHeight - size / 2;\n  var centerWidth = img.shape[1] / 2;\n  var beginWidth = centerWidth - size / 2;\n  if (grayscaleModel && !grayscaleInput) {\n    //cropped rgb data\n    var grayscale_cropped = img.slice([beginHeight, beginWidth, 0], [size, size, 3]);\n    grayscale_cropped = grayscale_cropped.reshape([size * size, 1, 3]);\n    var rgb_weights = [0.2989, 0.5870, 0.1140];\n    grayscale_cropped = tf.mul(grayscale_cropped, rgb_weights);\n    grayscale_cropped = grayscale_cropped.reshape([size, size, 3]);\n    grayscale_cropped = tf.sum(grayscale_cropped, -1);\n    grayscale_cropped = tf.expandDims(grayscale_cropped, -1);\n    return grayscale_cropped;\n  }\n  return img.slice([beginHeight, beginWidth, 0], [size, size, 3]);\n}\nexports.cropTensor = cropTensor;","map":{"version":3,"names":["tf","require","capture","rasterElement","grayscale","tidy","pixels","browser","fromPixels","cropped","cropTensor","batchedImage","expandDims","toFloat","div","scalar","sub","exports","img","grayscaleModel","grayscaleInput","size","Math","min","shape","centerHeight","beginHeight","centerWidth","beginWidth","grayscale_cropped","slice","reshape","rgb_weights","mul","sum"],"sources":["C:\\Users\\bhakt\\OneDrive\\Desktop\\gitupload\\depict_art\\node_modules\\@teachablemachine\\image\\src\\utils\\tf.ts"],"sourcesContent":["/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\n/**\r\n * Receives an image and normalizes it between -1 and 1.\r\n * Returns a batched image (1 - element batch) of shape [1, w, h, c]\r\n * @param rasterElement the element with pixels to convert to a Tensor\r\n * @param grayscale optinal flag that changes the crop to [1, w, h, 1]\r\n */\r\nexport function capture(rasterElement: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement, grayscale?: boolean) {\r\n    return tf.tidy(() => {\r\n        const pixels = tf.browser.fromPixels(rasterElement);\r\n\r\n        // crop the image so we're using the center square\r\n        const cropped = cropTensor(pixels, grayscale);\r\n\r\n        // Expand the outer most dimension so we have a batch size of 1\r\n        const batchedImage = cropped.expandDims(0);\r\n\r\n        // Normalize the image between -1 and a1. The image comes in between 0-255\r\n        // so we divide by 127 and subtract 1.\r\n        return batchedImage.toFloat().div(tf.scalar(127)).sub(tf.scalar(1));\r\n    });\r\n}\r\n\r\n\r\nexport function cropTensor( img: tf.Tensor3D, grayscaleModel?: boolean, grayscaleInput?: boolean ) : tf.Tensor3D {\r\n    const size = Math.min(img.shape[0], img.shape[1]);\r\n    const centerHeight = img.shape[0] / 2;\r\n    const beginHeight = centerHeight - (size / 2);\r\n    const centerWidth = img.shape[1] / 2;\r\n    const beginWidth = centerWidth - (size / 2);\r\n    \r\n    if (grayscaleModel && !grayscaleInput) {\r\n        //cropped rgb data\r\n        let grayscale_cropped = img.slice([beginHeight, beginWidth, 0], [size, size, 3]);\r\n        \r\n        grayscale_cropped = grayscale_cropped.reshape([size * size, 1, 3])\r\n        const rgb_weights = [0.2989, 0.5870, 0.1140]\r\n        grayscale_cropped = tf.mul(grayscale_cropped, rgb_weights)\r\n        grayscale_cropped = grayscale_cropped.reshape([size, size, 3]);\r\n    \r\n        grayscale_cropped = tf.sum(grayscale_cropped, -1)\r\n        grayscale_cropped = tf.expandDims(grayscale_cropped, -1)\r\n\r\n        return grayscale_cropped;\r\n    }\r\n    return img.slice([beginHeight, beginWidth, 0], [size, size, 3]);\r\n}\r\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiBA,IAAAA,EAAA,GAAAC,OAAA;AAEA;;;;;;AAMA,SAAgBC,OAAOA,CAACC,aAAsE,EAAEC,SAAmB;EAC/G,OAAOJ,EAAE,CAACK,IAAI,CAAC;IACX,IAAMC,MAAM,GAAGN,EAAE,CAACO,OAAO,CAACC,UAAU,CAACL,aAAa,CAAC;IAEnD;IACA,IAAMM,OAAO,GAAGC,UAAU,CAACJ,MAAM,EAAEF,SAAS,CAAC;IAE7C;IACA,IAAMO,YAAY,GAAGF,OAAO,CAACG,UAAU,CAAC,CAAC,CAAC;IAE1C;IACA;IACA,OAAOD,YAAY,CAACE,OAAO,EAAE,CAACC,GAAG,CAACd,EAAE,CAACe,MAAM,CAAC,GAAG,CAAC,CAAC,CAACC,GAAG,CAAChB,EAAE,CAACe,MAAM,CAAC,CAAC,CAAC,CAAC;EACvE,CAAC,CAAC;AACN;AAdAE,OAAA,CAAAf,OAAA,GAAAA,OAAA;AAiBA,SAAgBQ,UAAUA,CAAEQ,GAAgB,EAAEC,cAAwB,EAAEC,cAAwB;EAC5F,IAAMC,IAAI,GAAGC,IAAI,CAACC,GAAG,CAACL,GAAG,CAACM,KAAK,CAAC,CAAC,CAAC,EAAEN,GAAG,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;EACjD,IAAMC,YAAY,GAAGP,GAAG,CAACM,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;EACrC,IAAME,WAAW,GAAGD,YAAY,GAAIJ,IAAI,GAAG,CAAE;EAC7C,IAAMM,WAAW,GAAGT,GAAG,CAACM,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;EACpC,IAAMI,UAAU,GAAGD,WAAW,GAAIN,IAAI,GAAG,CAAE;EAE3C,IAAIF,cAAc,IAAI,CAACC,cAAc,EAAE;IACnC;IACA,IAAIS,iBAAiB,GAAGX,GAAG,CAACY,KAAK,CAAC,CAACJ,WAAW,EAAEE,UAAU,EAAE,CAAC,CAAC,EAAE,CAACP,IAAI,EAAEA,IAAI,EAAE,CAAC,CAAC,CAAC;IAEhFQ,iBAAiB,GAAGA,iBAAiB,CAACE,OAAO,CAAC,CAACV,IAAI,GAAGA,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAClE,IAAMW,WAAW,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC;IAC5CH,iBAAiB,GAAG7B,EAAE,CAACiC,GAAG,CAACJ,iBAAiB,EAAEG,WAAW,CAAC;IAC1DH,iBAAiB,GAAGA,iBAAiB,CAACE,OAAO,CAAC,CAACV,IAAI,EAAEA,IAAI,EAAE,CAAC,CAAC,CAAC;IAE9DQ,iBAAiB,GAAG7B,EAAE,CAACkC,GAAG,CAACL,iBAAiB,EAAE,CAAC,CAAC,CAAC;IACjDA,iBAAiB,GAAG7B,EAAE,CAACY,UAAU,CAACiB,iBAAiB,EAAE,CAAC,CAAC,CAAC;IAExD,OAAOA,iBAAiB;;EAE5B,OAAOX,GAAG,CAACY,KAAK,CAAC,CAACJ,WAAW,EAAEE,UAAU,EAAE,CAAC,CAAC,EAAE,CAACP,IAAI,EAAEA,IAAI,EAAE,CAAC,CAAC,CAAC;AACnE;AAtBAJ,OAAA,CAAAP,UAAA,GAAAA,UAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}